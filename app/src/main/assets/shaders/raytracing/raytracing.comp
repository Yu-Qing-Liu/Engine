#version 450

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

// ========================= Interfaces / Layouts =========================
struct BVHNode {
    vec4  bmin;              // xyz = bmin
    uint  leftFirst;         // INTERNAL: left child index  (LEAF: first tri index)
    uint  _pad0_0, _pad0_1, _pad0_2;
    vec4  bmax;              // xyz = bmax
    uint  rightOrCount;      // INTERNAL: 0x80000000 | rightIdx, LEAF: triCount
    uint  _pad1_0, _pad1_1, _pad1_2;
};

struct Ray { vec3 o; vec3 d; };

layout(std430, set=0, binding=0) readonly buffer BvhBuf  { BVHNode nodes[]; };
layout(std430, set=0, binding=1) readonly buffer TriBuf  { uvec4   tris[];  };
layout(std430, set=0, binding=2) readonly buffer PosBuf  { vec4    pos[];   };

layout(std140, set=0, binding=3) uniform Params {
    mat4 invViewProj;        // inverse(view * proj) used for unproject
    mat4 invModel;           // inverse(model) to move world ray into model space
    vec2 mouseNdc; vec2 _pad0;
    vec3 camPos;   int  _pad;
} u;

layout(std430, set=0, binding=4) buffer OutBuf {
    uint  hit;     // debug/hit code
    uint  primId;  // payload A
    float t;       // payload B
    float rayLen;  // ray length
    vec4 hitPos;   // xyz intersection
} outHit;

// =============================== Utils ==================================
#define DBG(c,a,b) { outHit.hit=uint(c); outHit.primId=uint(a); outHit.t=float(b); return; }

bool isLeaf(BVHNode n)          { return (n.rightOrCount & 0x80000000u) == 0u; }
uint rightChildIndex(BVHNode n) { return  n.rightOrCount & 0x7FFFFFFFu; }
uint leafCount(BVHNode n)       { return  n.rightOrCount; }

bool finite3(vec3 v){
    return all(lessThan(abs(v), vec3(3.0e37))) && !any(isnan(v));
}

// Unproject helpers
vec3 unprojectClip(vec2 ndc, float z01) {        // correct: z_clip = 2*z01-1
    float zClip = 2.0*z01 - 1.0;
    vec4 p = u.invViewProj * vec4(ndc, zClip, 1.0);
    return p.xyz / p.w;
}
bool safeUnprojectClip(vec2 ndc, float z01, out vec3 outP){
    float zClip = 2.0*z01 - 1.0;
    vec4 h = u.invViewProj * vec4(ndc, zClip, 1.0);
    if (abs(h.w) < 1e-20) return false;
    outP = h.xyz / h.w;
    return true;
}
bool safeUnprojectZ01(vec2 ndc, float z01, out vec3 outP){ // diagnostic: WRONG mapping
    vec4 h = u.invViewProj * vec4(ndc, z01, 1.0);
    if (abs(h.w) < 1e-20) return false;
    outP = h.xyz / h.w;
    return true;
}

// Build a model-space ray from NDC and a chosen Z mapping
bool buildRayFrom(vec2 ndc, bool useCorrectZ, out Ray r){
    vec3 wpNear, wpFar;
    bool ok0 = useCorrectZ ? safeUnprojectClip(ndc, 0.001, wpNear)
                           : safeUnprojectZ01 (ndc, 0.001, wpNear);
    bool ok1 = useCorrectZ ? safeUnprojectClip(ndc, 0.999, wpFar)
                           : safeUnprojectZ01 (ndc, 0.999, wpFar);
    if (!ok0 || !ok1) return false;

    vec3 oW = wpNear;
    vec3 dW = normalize(wpFar - wpNear);

    vec3 oM = (u.invModel * vec4(oW, 1.0)).xyz;
    vec3 dM = (u.invModel * vec4(dW, 0.0)).xyz;
    if (!finite3(dM)) return false;
    dM = normalize(dM);
    if (!finite3(dM) || length(dM) < 1e-12) return false;

    r.o = oM; r.d = dM;
    return true;
}

bool rayAabb(Ray r, vec3 bmin, vec3 bmax, out float t0, out float t1) {
    const float INF = 3.402823e38;

    float tx0, tx1_, ty0, ty1_, tz0, tz1_;

    // X
    if (abs(r.d.x) < 1e-12) {
        if (r.o.x < bmin.x || r.o.x > bmax.x) return false;
        tx0 = -INF; tx1_ =  INF;
    } else {
        float inv = 1.0 / r.d.x;
        float a = (bmin.x - r.o.x) * inv;
        float b = (bmax.x - r.o.x) * inv;
        tx0 = min(a, b); tx1_ = max(a, b);
    }

    // Y
    if (abs(r.d.y) < 1e-12) {
        if (r.o.y < bmin.y || r.o.y > bmax.y) return false;
        ty0 = -INF; ty1_ =  INF;
    } else {
        float inv = 1.0 / r.d.y;
        float a = (bmin.y - r.o.y) * inv;
        float b = (bmax.y - r.o.y) * inv;
        ty0 = min(a, b); ty1_ = max(a, b);
    }

    // Z
    if (abs(r.d.z) < 1e-12) {
        if (r.o.z < bmin.z || r.o.z > bmax.z) return false;
        tz0 = -INF; tz1_ =  INF;
    } else {
        float inv = 1.0 / r.d.z;
        float a = (bmin.z - r.o.z) * inv;
        float b = (bmax.z - r.o.z) * inv;
        tz0 = min(a, b); tz1_ = max(a, b);
    }

    t0 = max(max(tx0, ty0), max(tz0, 0.0));
    t1 = min(min(tx1_, ty1_), tz1_);
    return t0 <= t1;
}

bool rayTri(Ray r, vec3 a, vec3 b, vec3 c, out float t){
    vec3 e1 = b-a, e2 = c-a;
    vec3 p  = cross(r.d, e2);
    float det = dot(e1, p);
    if (abs(det) < 1e-8) return false;
    float inv = 1.0/det;
    vec3 s = r.o - a;
    float uB = dot(s, p) * inv; if (uB < 0.0 || uB > 1.0) return false;
    vec3 q = cross(s, e1);
    float vB = dot(r.d, q) * inv; if (vB < 0.0 || uB+vB > 1.0) return false;
    t = dot(e2, q) * inv; return t > 1e-6;
}

// =============================== Main ===================================
void main(){
    // DBG(900u, 0u, 0.0);

    outHit.hit = 0u;
    BVHNode root = nodes[0];

    Ray rA;
    if (!buildRayFrom(u.mouseNdc, /*useCorrectZ=*/true, rA)) {
        DBG(611u, 0u, 0.0);                // couldn't build ray
    }

    float t0, t1;

    // -------- BVH traversal with ray rA --------
    uint stack[64]; int sp = 0; stack[sp++] = 0u;
    float bestT = 3.4e38;
    uint  bestPrim = 0xFFFFFFFFu;

    while (sp > 0){
        uint ni = stack[--sp];
        BVHNode n = nodes[ni];

        float nt0, nt1;
        if (!rayAabb(rA, n.bmin.xyz, n.bmax.xyz, nt0, nt1) || nt0 > bestT) continue;

        if (!isLeaf(n)) {
            uint left  = n.leftFirst;
            uint right = rightChildIndex(n);
            if (sp <= 62) { stack[sp++] = right; stack[sp++] = left; }
        } else {
            uint first = n.leftFirst;
            uint count = leafCount(n);

            // DBG(300u, first, float(count));

            for (uint i = 0u; i < count; ++i){
                uvec4 tri = tris[first + i];
                vec3 A = pos[tri.x].xyz, B = pos[tri.y].xyz, C = pos[tri.z].xyz;
                float t;
                if (rayTri(rA, A,B,C, t) && t < bestT){ bestT = t; bestPrim = first + i; }
            }
        }
    }

    if (bestPrim != 0xFFFFFFFFu) {
        outHit.hit    = 1u;
        outHit.primId = bestPrim;
        outHit.t      = bestT;

        // model-space hit
        vec3 hitPosM = rA.o + bestT * rA.d;

        // build model matrix once (inverse of invModel)
        mat4 model = inverse(u.invModel);

        // world-space hit & length from camera
        vec3 hitPosW = (model * vec4(hitPosM, 1.0)).xyz;
        outHit.hitPos = vec4(hitPosW, 1.0);

        vec3 cam = u.camPos;           // already world-space
        outHit.rayLen = length(cam - hitPosW);
    } else {
        outHit.hit = 0u;
    }
}

