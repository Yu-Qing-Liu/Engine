#version 450

struct Particle {
    vec2  position;
    vec2  velocity;   // DIRECTION (will be normalized)
    vec4  color;
    float size;       // animated
    float speedScale; // SPEED magnitude (units/sec)
    float sizeFreq;   // Hz
    float sizePhase;  // rad
    float baseSize;   // px
    float _pad0, _pad1, _pad2; // keep your 64B stride if you padded on CPU
};

layout(binding = 0) uniform ParameterUBO {
    float deltaTime;     // seconds
    uint  particleCount;
    uint  _padA, _padB;
} ubo;

layout(std430, binding = 1) readonly buffer ParticleSSBOIn  { Particle particlesIn[];  };
layout(std430, binding = 2)         buffer ParticleSSBOOut { Particle particlesOut[]; };

layout(local_size_x = 256) in;

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= ubo.particleCount) return;

    Particle pin  = particlesIn[index];
    Particle pout = pin;

    // --- time ---
    float dt = clamp(ubo.deltaTime, 0.0, 1.0/30.0);

    // --- rebuild velocity with constant speed ---
    vec2 dir = pin.velocity;
    float len = length(dir);
    if (len < 1e-6) {
        // fallback random-ish unit dir from phase (deterministic)
        float a = fract(sin(pin.sizePhase) * 43758.5453) * 6.28318530718;
        dir = vec2(cos(a), sin(a));
        len = 1.0;
    }
    dir /= len;
    float speed = max(pin.speedScale, 1e-5);   // constant speed (units/sec)
    vec2 v = dir * speed;

    // --- integrate ---
    vec2 pos = pin.position + v * dt;

    // --- bounce keeping speed (flip component, keep magnitude) ---
    const float minX = -1.0, maxX =  1.0;
    const float minY = -1.0, maxY =  1.0;
    const float eps  = 1e-4;

    if (pos.x < minX) { pos.x = minX + eps; v.x =  abs(v.x); }
    if (pos.x > maxX) { pos.x = maxX - eps; v.x = -abs(v.x); }
    if (pos.y < minY) { pos.y = minY + eps; v.y =  abs(v.y); }
    if (pos.y > maxY) { pos.y = maxY - eps; v.y = -abs(v.y); }

    // store back direction equivalent
    pout.position = pos;
    pout.velocity = v; // next frame we'll renormalize to keep |v| = speedScale

    // --- slow, smooth size breathing (no flashing) ---
    pout.sizePhase = pin.sizePhase + (6.28318530718 * pin.sizeFreq) * dt * 0.2; // 2Ï€f
    float osc = 0.75 + 0.25 * sin(pout.sizePhase);   // 0.5..1.0
    float targetSize = pin.baseSize * osc;
    float smoothing  = 1.0 - exp(-4.0 * dt);         // ~250 ms time constant
    pout.size = mix(pin.size, targetSize, smoothing);

    // alpha follows growth (lower when small, higher when large)
    float grow = clamp((osc - 0.5) * 2.0, 0.0, 1.0);  // map 0.5..1.0 -> 0..1
    float alpha = mix(0.1, 0.2, grow);               // min/max alpha; tweak to taste
    pout.color.a = alpha;

    particlesOut[index] = pout;
}

