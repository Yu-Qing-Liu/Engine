#include "destinationmarker.hpp"

DestinationMarker::DestinationMarker(Scene *scene) : ShaderQuad(scene) {
	pc = DestinationMarkerPC{};
	setFragmentShader(std::string("#version 450\n"
								  "layout(location = 0) in vec2 vLocal;\n"
								  "layout(location = 0) out vec4 outColor;\n"
								  "\n"
								  "layout(push_constant) uniform PushConstants {\n"
								  "    float time;\n"
								  "} pc;\n"
								  "\n"
								  "mat2 rot(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }\n"
								  "float aastep(float d){ float w=max(fwidth(d), 1e-4); return smoothstep(0.0, w, d); }\n"
								  "\n"
								  "void main(){\n"
								  "    // IMPORTANT: your quad vertices are in [-0.5..0.5], so scale to [-1..1]\n"
								  "    vec2 p = vLocal * 2.0;\n"
								  "    float r = length(p);\n"
								  "\n"
								  "    float radius = 0.75;\n"
								  "    float borderThickness = 0.06;\n"
								  "\n"
								  "    float inside = 1.0 - aastep(r - radius);\n"
								  "\n"
								  "    float halfT = borderThickness * 0.5;\n"
								  "    float ring  = 1.0 - aastep(abs(r - radius) - halfT);\n"
								  "\n"
								  "    // Dashed border rotating one way\n"
								  "    float borderAngle = +pc.time * 1.3;\n"
								  "    vec2 pr = rot(borderAngle) * p;\n"
								  "    float ang = atan(pr.y, pr.x);\n"
								  "    float u = (ang + 3.14159265359) / 6.28318530718;\n"
								  "\n"
								  "    float dashCount = 4.0;\n"
								  "    float duty = 0.55;\n"
								  "    float t = fract(u * dashCount);\n"
								  "    float e = max(fwidth(u * dashCount), 1e-4);\n"
								  "    float dashOn = smoothstep(0.0, e, t) * (1.0 - smoothstep(duty - e, duty, t));\n"
								  "    float dashedRing = ring * dashOn;\n"
								  "\n"
								  "    // Cross rotating the opposite way\n"
								  "    float crossAngle = -pc.time * 1.3;\n"
								  "    vec2 pcross = rot(crossAngle) * p;\n"
								  "    float crossLen = radius * 0.25;\n"
								  "    float crossTh  = radius * 0.025;\n"
								  "    float dh = max(abs(pcross.y) - crossTh, abs(pcross.x) - crossLen);\n"
								  "    float dv = max(abs(pcross.x) - crossTh, abs(pcross.y) - crossLen);\n"
								  "    float dCross = min(dh, dv);\n"
								  "    float crossMask = (1.0 - aastep(dCross)) * inside;\n"
								  "\n"
								  "    vec4 fill   = vec4(1.0, 0.75, 0.15, 0.28);\n"
								  "    vec4 border = vec4(1.0, 0.95, 0.25, 1.0);\n"
								  "    vec4 cross  = vec4(1.0, 0.98, 0.55, 1.0);\n"
								  "\n"
								  "    vec4 col = vec4(0.0);\n"
								  "    // Fill only inside circle\n"
								  "    col.rgb += fill.rgb * fill.a * inside;\n"
								  "    col.a   += fill.a * inside;\n"
								  "\n"
								  "    // Dashed border over fill\n"
								  "    col.rgb = mix(col.rgb, border.rgb, dashedRing);\n"
								  "    col.a   = max(col.a, border.a * dashedRing);\n"
								  "\n"
								  "    // Cross over everything\n"
								  "    col.rgb = mix(col.rgb, cross.rgb, crossMask);\n"
								  "    col.a   = max(col.a, cross.a * crossMask);\n"
								  "\n"
								  "    // Prevent seeing a full quad if blending/setup is not what we expect\n"
								  "    float coverage = max(fill.a * inside, max(dashedRing, crossMask));\n"
								  "    if (coverage <= 0.0) discard;\n"
								  "\n"
								  "    outColor = col;\n"
								  "}\n"));
}
