#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct BVHNode {
    vec4 bmin;
    uint leftFirst;
    uint _pad0_0, _pad0_1, _pad0_2;
    vec4 bmax;
    uint rightOrCount;
    uint _pad1_0, _pad1_1, _pad1_2;
};

layout(std430, set = 0, binding = 0) readonly buffer BvhBuf { BVHNode nodes[]; };
layout(std430, set = 0, binding = 1) readonly buffer TriBuf { uvec4  tris[];  };
layout(std430, set = 0, binding = 2) readonly buffer PosBuf { vec4   pos[];   };

layout(std140, set = 0, binding = 3) uniform Params {
    mat4 invViewProj;
    vec2 mouseNdc;   // currently coming in Y-up; we will flip Y here
    vec2 _pad0;
    vec3 camPos;
    int  instanceCount;
    int  _pad1[3];
} u;

layout(std430, set = 0, binding = 4) buffer OutBuf {
    uint  hit;
    uint  primId;
    float t;
    float rayLen;
    vec4  hitPos;
} outHit;

struct InstanceXform { mat4 model; mat4 invModel; };
layout(std430, set = 0, binding = 5) readonly buffer InstBuf { InstanceXform inst[];     };
layout(std430, set = 0, binding = 6) readonly buffer IdBuf   { int           slotToKey[]; };

struct Ray { vec3 o; vec3 d; };

bool finite3(vec3 v) {
    return all(lessThan(abs(v), vec3(3.0e37))) && !any(isnan(v));
}

// NOTE: This version uses GL-style NDC Z (-1..+1) since your code below did.
// If your CPU uses Vulkan Z (0..1), switch the -1.0 to 0.0.
bool buildWorldRay(vec2 ndc, out Ray rW) {
    vec4 pN = u.invViewProj * vec4(ndc, -1.0, 1.0);
    vec4 pF = u.invViewProj * vec4(ndc,  1.0, 1.0);

    if (abs(pN.w) < 1e-20 || abs(pF.w) < 1e-20) return false;

    pN.xyz /= pN.w;
    pF.xyz /= pF.w;

    vec3 dir = normalize(pF.xyz - pN.xyz);
    if (!finite3(dir)) return false;

    rW.o = pN.xyz;
    rW.d = dir;
    return true;
}

bool rayAabb(Ray r, vec3 bmin, vec3 bmax, out float t0, out float t1) {
    const float INF = 3.402823e38;
    float tx0, tx1_, ty0, ty1_, tz0, tz1_;

    if (abs(r.d.x) < 1e-12) { if (r.o.x < bmin.x || r.o.x > bmax.x) return false; tx0 = -INF; tx1_ = INF; }
    else { float inv = 1.0 / r.d.x; float a = (bmin.x - r.o.x) * inv, b = (bmax.x - r.o.x) * inv; tx0 = min(a,b); tx1_ = max(a,b); }

    if (abs(r.d.y) < 1e-12) { if (r.o.y < bmin.y || r.o.y > bmax.y) return false; ty0 = -INF; ty1_ = INF; }
    else { float inv = 1.0 / r.d.y; float a = (bmin.y - r.o.y) * inv, b = (bmax.y - r.o.y) * inv; ty0 = min(a,b); ty1_ = max(a,b); }

    if (abs(r.d.z) < 1e-12) { if (r.o.z < bmin.z || r.o.z > bmax.z) return false; tz0 = -INF; tz1_ = INF; }
    else { float inv = 1.0 / r.d.z; float a = (bmin.z - r.o.z) * inv, b = (bmax.z - r.o.z) * inv; tz0 = min(a,b); tz1_ = max(a,b); }

    t0 = max(max(tx0, ty0), max(tz0, 0.0));
    t1 = min(min(tx1_, ty1_), tz1_);
    return t0 <= t1;
}

bool rayTri(Ray r, vec3 a, vec3 b, vec3 c, out float t) {
    vec3 e1 = b - a, e2 = c - a;
    vec3 p  = cross(r.d, e2);
    float det = dot(e1, p);
    if (abs(det) < 1e-8) return false;
    float inv = 1.0 / det;
    vec3  s   = r.o - a;
    float uB  = dot(s, p) * inv; if (uB < 0.0 || uB > 1.0) return false;
    vec3  q   = cross(s, e1);
    float vB  = dot(r.d, q) * inv; if (vB < 0.0 || uB + vB > 1.0) return false;
    t = dot(e2, q) * inv;
    return t > 1e-6;
}

void main() {
    outHit.hit    = 0u;
    outHit.t      = 0.0;
    outHit.rayLen = 0.0;
    outHit.primId = 0xFFFFFFFFu;
    outHit.hitPos = vec4(0.0);

    // ---- THE ONE-LINE FIX: flip Y here ----
    vec2 ndc = vec2(u.mouseNdc.x, -u.mouseNdc.y);

    Ray rW;
    if (!buildWorldRay(ndc, rW)) {
        return;
    }

    float bestT        = 3.4e38;
    uint  bestPrim     = 0xFFFFFFFFu;
    int   bestModelId  = -1;
    uint  bestInstIdx  = 0u;

    uint N = uint(max(u.instanceCount, 0));
    for (uint i = 0u; i < N; ++i) {
        vec3 oM = (inst[i].invModel * vec4(rW.o, 1.0)).xyz;
        vec3 dM = (inst[i].invModel * vec4(rW.d, 0.0)).xyz;
        dM = normalize(dM);
        if (!finite3(dM)) continue;

        Ray rM; rM.o = oM; rM.d = dM;

        uint stack[64];
        int  sp = 0;
        stack[sp++] = 0u;

        float bestT_i   = bestT;
        uint  bestPrim_i = 0xFFFFFFFFu;

        while (sp > 0) {
            uint ni = stack[--sp];
            BVHNode n = nodes[ni];

            float nt0, nt1;
            if (!rayAabb(rM, n.bmin.xyz, n.bmax.xyz, nt0, nt1) || nt0 > bestT_i) continue;

            if ((n.rightOrCount & 0x80000000u) != 0u) {
                uint left  = n.leftFirst;
                uint right = n.rightOrCount & 0x7FFFFFFFu;
                if (sp <= 62) { stack[sp++] = right; stack[sp++] = left; }
            } else {
                uint first = n.leftFirst;
                uint count = n.rightOrCount;
                for (uint k = 0u; k < count; ++k) {
                    uvec4 tri = tris[first + k];
                    vec3 A = pos[tri.x].xyz;
                    vec3 B = pos[tri.y].xyz;
                    vec3 C = pos[tri.z].xyz;
                    float t;
                    if (rayTri(rM, A, B, C, t) && t < bestT_i) {
                        bestT_i   = t;
                        bestPrim_i = first + k;
                    }
                }
            }
        }

        if (bestPrim_i != 0xFFFFFFFFu && bestT_i < bestT) {
            bestT       = bestT_i;
            bestPrim    = bestPrim_i;
            bestModelId = slotToKey[i];
            bestInstIdx = i;
        }
    }

    if (bestPrim != 0xFFFFFFFFu) {
        outHit.hit    = 1u;
        outHit.primId = uint(bestModelId);
        outHit.t      = bestT;

        vec3 oM = (inst[bestInstIdx].invModel * vec4(rW.o, 1.0)).xyz;
        vec3 dM = (inst[bestInstIdx].invModel * vec4(rW.d, 0.0)).xyz;
        dM = normalize(dM);
        vec3 hitPosI = oM + bestT * dM;
        vec3 hitPosW = (inst[bestInstIdx].model * vec4(hitPosI, 1.0)).xyz;

        outHit.hitPos = vec4(hitPosW, 1.0);
        outHit.rayLen = length(hitPosW - u.camPos);
    }
}

